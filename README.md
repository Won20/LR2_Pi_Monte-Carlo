# LR2_Pi_Monte-Carlo
Вычисление числа Pi методом Монте-Карло: https://colab.research.google.com/drive/1_EMjYJE5L3Rl8RcNKV4tZsnI3pIrmI6j?usp=sharing

# Задача: 
Реализовать алгоритм вычисления числа PI.

Учитывая количество точек N, сгенерируйте случайное распределение в области (0; 0)-(1; 1) и вычислите число используя CPU и GPU. Полученные значения должны быть распечатаны вместе со временем выполнения.

Входные данные: количество точек.

Выходные данные: время выполнения и полученные числа PI.

Реализация должна содержать 2 функции вычисления числа PI: на CPU и на GPU с применением CUDA.

# Реализация:
Вычисление числа Pi осуществляется с использованием вероятностного метода Монте-Карло. Алгоритм данного метода:
![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/174b7195-2125-476a-a83d-f9155d778b33)
![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/a2d20db7-dc72-44df-86b0-ab0db5c48dd9)

Фнукции GPU__Pi_monte() и dev_vec() производят вычисление числа Pi на графическом процессоре. Функция CPU__Pi_monte() производит вычисления на центральном процессоре.
Генерация данных производилась на графическом процессоре при помощи Numba, у которой генерация  нормально распределенных случайных чисел из универсального генератора происходит аналогично  cuRAND и использует преобразование Бокса-Мюллера. Функция create_xoroshiro128p_states инициализирует генератор случайных чисел CUDA. Функция xoroshiro128p_uniform_float32() возвращает последовательность псевдослучайных чисел с плавающей запятой, равномерно распределенных между 0,0 и 1,0.

# Результаты
В таблице приведены результаты времени выполнения вычисления числа Pi и ускорение:
![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/ab46bace-a9ea-460d-a87e-e801ddb13c07) ![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/46af3ddc-398b-4f90-b980-0062b894a887) ![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/3f1cbb9d-fd37-4736-96e4-b274e64f2e29)

Из данных таблиц можно увидеть, что оба алгоритма обеспечивают достаточно хорошую точность.
Однако, не трудно заметить, что алгоритм реализованный на GPU работает быстрее.

Графики зависимости времени и ускорения от количества точек N:
![image](https://github.com/Won20/LR2_Pi_Monte-Carlo/assets/102918065/e6ac47f7-4d2a-410c-be4f-122c2e75d97b)

# Вывод:
В результате выполнения лабораторной работы был реализован алгоритм вычисления числа Pш на CPU и GPU. Работа выполнена на языке Python, с применением библиотека numba для задействования GPU Device. Точность вычислений сопоставима и близка к истине, но на выполняется GPU заметно быстрее.












